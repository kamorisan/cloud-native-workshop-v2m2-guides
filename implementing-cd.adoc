= Lab1 - Automating Deployments Using Pipelines
:experimental:

前のシナリオでは、OpenShiftテンプレートを使用して Coolstore monolith を、 *{{USER_ID}}-coolstore-dev* Project にデプロイしました。このテンプレートによって必要なオブジェクト（BuildConfig、DeploymentConfig、ImageStreams、Services、およびRoute）が作成され、開発者としてアプリを実行し、変更を加え、デバッグするための場が提供されました。

このステップでは、別の本番環境を設定し、開発者や DevOps チームが開発者 *(あなたのことです！)* から本番環境にコードを移行する際のベストプラクティスやテクニックを探っていきます。

=== Production vs. Development

既存の *{{USER_ID}}-coolstore-dev* project は、コード変更後のアプリの新バージョンをビルドしてデプロイするための開発環境として利用されています。

OpenShift上の実際のプロジェクトでは、開発環境とテスト環境と本番環境では、通常、異なるOpenShiftプロジェクトを使用し、おそらくは異なるOpenShiftクラスタを使用することになるでしょう。.

このシナリオを簡単にするために、私たちは開発環境と本番環境のみを使用し、テスト/QA環境は使用しません。

==== 1. Create the production environment

{{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-coolstore-dev[Topology View^] に戻って、 プロジェクトのドロップダウンをクリックして、 *Create Project* を選択します。

image::create_project.png[create_dialog, 600]

フィールドに必要事項を入力し、 `Create` をクリックします。

* Name: *{{USER_ID}}-coolstore-prod*
* Display Name: *{{USER_ID}} Coolstore Monolith - Production*
* Description: _空欄にする_

[WARNING]
====
プロジェクト名に `{{USER_ID}}-coolstore-prod` を使用しなければなりません。 この名前は後に参照されるため、 `{{USER_ID}}-coolstore-prod` という名前を付けないと失敗することになります。
====

これで *{{USER_ID}}-coolstore-prod* という新しいOpenShiftプロジェクトが作成され、そこから本番アプリケーションが実行されます。

==== 2. Add the production elements

今回は本番用のテンプレートを使ってオブジェクトを作成します。

使用するアプリケーションテンプレートをあらかじめインストールしておきました。 *+Add* をクリックして、 *From Catalog* の項目をクリックします。

image::from_catalog.png[create_new, 700]

検索ボックスに `coolstore` と入力し、 `Coolstore Monolith using pipelines` を選択し、 `Instantiate Template` をクリックします。

image::from_catalog_prod.png[create_new, 700]

以下の項目を記入してください。

* *Namespace*: `{{ USER_ID }}-coolstore-prod` (これは既に選択されているはずです)
* *User ID*: `{{ USER_ID }}`

image::from_catalog_prod_details.png[create_new, 700]

他の値はそのままにして、下にスクロールして *Create* をクリックします。

{{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-coolstore-prod[Topology View^] に移動して、デプロイされた要素を確認します。

ウェブコンソールの開発者視点の *Topology* view では、プロジェクト内のすべてのアプリケーション、そのビルドステータス、およびそれらに関連するコンポーネントとサービスを視覚的に表示します。

CodeReadyターミナルでこのコマンドを実行することで、コンポーネントに適切なアイコンが表示されるようにラベルを付けます。

[source,sh,role="copypaste"]
----
oc project {{USER_ID}}-coolstore-prod && \
oc label dc/coolstore-prod-postgresql app.openshift.io/runtime=postgresql --overwrite && \
oc label dc/coolstore-prod app.openshift.io/runtime=jboss --overwrite && \
oc label dc/coolstore-prod-postgresql app.kubernetes.io/part-of=coolstore-prod --overwrite && \
oc label dc/coolstore-prod app.kubernetes.io/part-of=coolstore-prod --overwrite && \
oc annotate dc/coolstore-prod app.openshift.io/connects-to=coolstore-prod-postgresql --overwrite && \
oc annotate dc/coolstore-prod app.openshift.io/vcs-uri=https://github.com/RedHat-Middleware-Workshops/cloud-native-workshop-v2m2-labs.git --overwrite && \
oc annotate dc/coolstore-prod app.openshift.io/vcs-ref=ocp-4.5 --overwrite
----

image::coolstore_topology.png[create_new, 700]

実行中のpostgresデータベース(紺色の円)と、まだデプロイも起動もされていない coolstore monolith を見ることができます。以前のラボでは、開発者プロジェクトのアプリのバイナリビルドから手動でデプロイしました。このラボでは、CI/CD パイプラインを使用してビルドし、本番環境に自動的にデプロイします。

プロジェクトでは *Jenkins Server* を使用し、Jenkins パイプライン の ビルドストラテジー を使用します。

*Add* をクリックしてから、 *From Catalog* をクリックし、検索ボックスに `jenkins` と入力して、最初の *Jenkins (ephemeral)* アイテムを選択します。

image::from_catalog_jenkins.png[create_new, 700]

*Instantiate Template* をクリックして、以下のフィールドを変更し、他のフィールドはそのままにしておきます。

* *Namespace*: `{{ USER_ID }}-coolstore-prod` (これは既に選択されているはずです)
* *Memory Limit*: `2Gi`
* *Disable memory intensive administrative monitors*: `true`

*Create* をクリックしてください。

新しい Jenkins server にラベルを付けてみましょう。

[source,sh,role="copypaste"]
----
oc label dc/jenkins app.openshift.io/runtime=jenkins --overwrite
----

{{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-coolstore-prod[Topology View^] に戻ると、本番用のデータベースと、OpenShiftがCI/CDパイプラインの配置を管理するために使用している、Jenkinsと呼ばれるアプリケーションを見ることができます。

image::coolstore_prod_jenkins.png[create_new, 700]

まだ本番環境で動作しているアプリはありません。唯一の稼働中のアプリは、以前バイナリビルドを使ってアプリを稼働させていた開発環境に戻っています。

次のステップでは、OpenShiftのパイプラインビルドを使って、アプリを開発環境から本番環境に昇格させていきます。さっそくやってみましょう。

=== Promoting Apps Across Environments with Pipelines

ここまでは開発環境のOpenShiftに手動でアプリをビルドしてデプロイしてきました。ローカル開発には便利なのですが、テスト環境や本番環境に拡張するとエラーになりやすい配信方法です。

*Continuous Delivery (CD)* とは、デリバリーソフトウェアの様々な側面を自動化することを目的とした一連のプラクティスのことを指します。これらのプラクティスの1つは、デリバリーパイプラインと呼ばれるもので、コードや設定の変更が上位環境に到達し、最終的には本番環境に到達するまでのステップを定義する自動化されたプロセスです。

OpenShiftは人気のある https://jenkins.io/doc/book/pipeline/overview/[Jenkins pipelines^] をプラットフォームに統合することでCI/CD Pipelinesの構築を簡素化し、真に複雑なワークフローをOpenShift内から直接定義できるようにしました。OpenShift 4では、Kubernetes向けのCI/CDの進化形である https://www.openshift.com/learn/topics/pipelines[Tekton Pipelines^] も導入されています。

あらゆるデプロイメントパイプラインの最初のステップは、すべてのコードと設定をソースコードリポジトリに保存することです。今回のワークショップでは、ソースコードと設定を https://github.com/RedHat-Middleware-Workshops/cloud-native-workshop-v2m2-labs[GitHub repository^] に保存しています。
を使用しています。

OpenShiftは、開発者がJenkins自動化エンジンで実行するための https://jenkins.io/solutions/pipeline/[Jenkins pipeline^] を定義できるようにすることで、 *Jenkins CI/CD pipelines* をビルトインでサポートしています。

The build can get started, monitored, and managed by OpenShift in the same way as any other build types e.g. S2I. Pipeline workflows are defined in a `Jenkinsfile`, either embedded directly in the build configuration, or supplied in Git repository and referenced by the build configuration. They are written using the http://groovy-lang.org/[Groovy scripting language].

ビルドは、S2Iなどの他のビルドタイプと同じ方法でOpenShiftによって開始、監視、管理されます。パイプラインワークフローは `Jenkinsfile` で定義されており、ビルド設定に直接埋め込まれているか、Git リポジトリで提供され、ビルド設定で参照されます。これらは http://groovy-lang.org/[Groovy scripting language] を使って記述します。

最後のステップで使用した本番環境テンプレートの一部として、Pipeline ビルドオブジェクトが作成されました。通常、パイプラインには、開発環境でプロジェクトをビルドし、結果のイメージをローカルリポジトリに保存し、イメージを実行してそれに対してテストを実行し、結果のイメージをテストや本番環境などの他の環境に転送するために人の承認を待つというステップが含まれています。

==== 3. Inspect the Pipeline Definition

[NOTE]
====
OpenShift Consoleの左メニューにPipelinesというメニュー項目があるのに気づくかもしれません。このメニュー項目はTektonプロジェクトをベースにした新しいパイプライン技術であるTekton Pipelinesを探索するためのものです。このワークショップの一部として、Tektonを探索する他のモジュールもあります。今のところはJenkinsに集中しています。
====

このワークショップの目的のために、パイプラインはやや簡略化されています。パイプラインの内容を確認するには、 {{ CONSOLE_URL }}/k8s/ns/{{USER_ID}}-coolstore-prod/buildconfigs[Build Config page^] に移動して、 `monolith-pipeline` をクリックしてください。

image::prod_bc.png[create_new, 700]

すると、右側にJenkinsfileの詳細が表示されます。

image::coolstore-prod-monolith-bc.png[monolith-pipeline, 700]

また、CodeReady Workspacesのターミナルウィンドウから以下のコマンドで検査することもできます。

[source,sh,role="copypaste"]
----
oc describe bc/monolith-pipeline -n {{USER_ID}}-coolstore-prod
----

パイプライン構文では、複雑なデプロイメントシナリオを作成することができ、 https://jenkins.io/doc/pipeline/steps/[Jenkinsが提供するステップとプラグインの大規模なセット] を使用して手動での相互作用と承認プロセスのチェックポイントを定義することで、チームで使用されるプロセスにパイプラインを適応させることができます。

このワークショップでは、パイプラインを簡単にするために、ビルドとテストをシミュレートして、人間の入力を省略しています。パイプラインが完了すると、 `openshift` オブジェクト内の上記の `tag()` メソッドを使って、開発環境から本番環境にアプリをデプロイします。

==== 4. Promote the dev image to production using the pipeline

ビルドパイプラインを起動してみましょう。

{{ CONSOLE_URL }}/k8s/ns/{{USER_ID}}-coolstore-prod/buildconfigs/monolith-pipeline[Pipeline Details Page^]　のページで、 *Actions > Start Build* を選択してください。

image::pipe-start.png[Prod, 700]

これでパイプラインが開始されます。パイプラインを開始するのに1～2分かかります! 今後の実行は、Jenkinsのインフラストラクチャがすでにウォームアップされているので、それほど時間はかからないでしょう。パイプラインの進行状況を見ることができます。

image::pipe-prog.png[Prod, 700]

パイプラインが完了したら、 {{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-coolstore-prod[Topology View^] に戻り、アプリケーションがデプロイされて実行されていることを確認します!

image::pipe-done.png[Prod, 700]

コンテナが完全にデプロイされるまでに時間がかかる場合があります。

*おめでとうございます！* プロジェクトの開発・生産環境のセットアップが完了し、今後のプロジェクトでもこのワークフローを使用することができます。

次のステップでは、パイプラインにヒューマンインタラクション要素を追加して、プロジェクトリーダーであるあなたが変更の承認を担当できるようにします。

==== 5. Adding Pipeline Approval Steps

前のステップでは、OpenShift Pipelineを使用して、開発環境から本番環境への変更のビルドとデプロイのプロセスを自動化しました。このステップでは、パイプラインに最終チェックポイントを追加します。

通常、パイプラインの定義はGitのようなソースコード管理システムにチェックされ、パイプラインを変更するにはソースベースのJenkinsfileを編集します。今回のワークショップでは、直接編集して必要な変更を加えます。 *oc* コマンドでも編集できますが、ここではWebコンソールを使用します。

{{ CONSOLE_URL }}/k8s/ns/{{ USER_ID }}-coolstore-prod/buildconfigs/monolith-pipeline[Pipeline Details Page^] に戻って、 *YAML* タブをクリックします。Deploy to PROD ステージの直前に、パイプラインに新しいステージを追加します。

[NOTE]
====
下の画像のように、以下のコードを *BuildConfig* の適切な場所にコピー＆ペーストする必要があります。
====

[source,groovy, role="copypaste"]
----
            stage ('Approve Go Live') {
              steps {
                timeout(time:30, unit:'MINUTES') {
                  input message:'Go Live in Production (switch to new version)?'
                }
              }
            }
----

最終的なパイプラインは以下のようになります。

image::pipe-edit2.png[Prod, 700]

*Save* をクリックしてください。

==== 6. Make a simple change to the app

承認ステップが整ったので、coolstore のヘッダーの背景色を青に変更したいという、開発者からの変更をシミュレーションしてみましょう。

まず、CodeReadyの `cloud-native-workshop-v2m2-lab` プロジェクトで、CoolStoreアプリのCSSスタイルシートを含む _monolith/src/main/webapp/app/css/coolstore.css_ を開きます。

以下のCSSを追加して、ヘッダーバーの背景をブルーにします（※下の方にコピーして追加します）。

[source,css, role="copypaste"]
----
.navbar-header {
    background: blue
}
----

Now we need to update the catalog endpoint in the monolith application. Run the following commands in a Terminal to update the baseUrl to the proper value with your username:

[source,sh,role="copypaste"]
----
JSPATH="$CHE_PROJECTS_ROOT/cloud-native-workshop-v2m2-labs/monolith/src/main/webapp/app/services/catalog.js"
CATALOGHOST=$(oc get route -n {{ USER_ID}}-catalog catalog-springboot -o jsonpath={% raw %}"{.spec.host}"{% endraw %})
sed -i 's/REPLACEURL/'$CATALOGHOST'/' "$JSPATH"
----

Next, re-build the app once more via CodeReady Workspaces Terminal:

[source,sh,role="copypaste"]
----
mvn clean package -Popenshift -DskipTests -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m2-labs/monolith
----

And re-deploy it to the *dev* environment using a binary build just as we did before via CodeReady Workspaces Terminal:

[source,sh,role="copypaste"]
----
oc start-build -n {{USER_ID}}-coolstore-dev coolstore --from-file=$CHE_PROJECTS_ROOT/cloud-native-workshop-v2m2-labs/monolith/deployments/ROOT.war --follow
----
Wait for it to complete the deployment via CodeReady Workspaces Terminal:

[source,sh,role="copypaste"]
----
oc -n {{USER_ID}}-coolstore-dev rollout status -w dc/coolstore
----

And verify that the blue header is visible in the *dev* application by navigating to the http://www-{{USER_ID}}-coolstore-dev.{{ ROUTE_SUBDOMAIN}}[Coolstore Dev Web frontend^]. It should look like the following:

[WARNING]
====
If it doesn’t, you may need to do a hard browser refresh. Try holding the shift key while clicking the browser refresh button, or opening a separate "Private Browser" session to access the UI.
====

image::nav-blue.png[Dev, 700]

Confirm the http://www-{{USER_ID}}-coolstore-prod.{{ ROUTE_SUBDOMAIN}}[Coolstore Prod Web frontend^] is still using the original black header:

image::pipe-orig.png[Prod, 700]

We’re happy with this change in *dev*, so let’s promote the new change to *prod*, using the new approval step!

==== 7. Run the pipeline again

Invoke the pipeline once more by navigating to the {{ CONSOLE_URL }}/k8s/ns/{{USER_ID}}-coolstore-prod/buildconfigs/monolith-pipeline[Pipeline Details Page^], select _Actions > Start Build_.

The same pipeline progress will be shown, however before deploying to prod, you will see a prompt in the pipeline:

image::pipe-start2.png[Prod, 700]

Click on the link for *Input Required*. This will open a new tab and direct you to Jenkins itself, where you can login with the same credentials as OpenShift:

* Username: `{{USER_ID}}`
* Password: `{{OPENSHIFT_USER_PASSWORD}}`

Accept the browser certificate warning and the Jenkins/OpenShift permissions, and then you’ll find yourself at the approval prompt:

Click on *Console Output* on left menu then click on `Proceed`.

image::pipe-jenkins-prompt.png[Prod, 700]

=== 8. Approve the change to go live

Click *Proceed*, which will approve the change to be pushed to production. You could also have clicked *Abort* which would stop the pipeline immediately in case the change was unwanted or unapproved.

Once you click _Proceed_, you will see the log file from Jenkins showing the final progress and deployment.

On the {{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-coolstore-prod[Production Topology View^], wait for the production deployment to complete (and you get all blue circles!).

Once it completes, verify that the http://www-{{USER_ID}}-coolstore-prod.{{ ROUTE_SUBDOMAIN}}[Coolstore Prod Web frontend^] has the new change (blue header):

image::nav-blue.png[Prod, 700]

[WARNING]
====
It may take a few seconds for the new app to be available, since we've not configured a proper health check and are not using _Rolling Updates_ when deploying new apps. Real production environments would use this to ensure no downtime.

If you don't see a blue header, or you get _Application Not Available_ errors, wait a few moments and reload. If you are still getting a black header, try holding the shift key while clicking the browser refresh button to force a hard refresh.
====

Congratulations! You have added a human approval step for all future developer changes. You now have two projects that can be
visualized as:

image::goal.png[Prod, 700]

=== Summary


In this lab, you learned how to use the OpenShift Container Platform as a developer to build, and deploy applications. You also learned how OpenShift makes your life easier as a developer, architect, and DevOps engineer.

You can use these techniques in future projects to modernize your existing applications and add a lot of functionality without major re-writes.

The monolithic application we’ve been using so far works great, but is starting to show its age. Even small changes to one part of the app require many teams to be involved in the push to production.
